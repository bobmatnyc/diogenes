'use client';

import { useUser } from '@clerk/nextjs';
import { useEffect, useRef, useState, useCallback } from 'react';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Loader2 } from 'lucide-react';
import { isDevelopment } from '@/lib/env';
import { getRandomStarter } from '@/lib/prompts/core-principles';
import { BOB_CONVERSATION_STARTERS } from '@/lib/prompts/bob-matsuoka';
import { type PersonalityType } from '@/components/PersonalitySelector';
import { 
  addMessageToSession, 
  clearSession, 
  createNewSession, 
  getSession 
} from '@/lib/session';
import { 
  calculateCost, 
  estimateMessagesTokens, 
  estimateTokens 
} from '@/lib/tokens';
import { DEFAULT_MODEL_ID } from '@/types/chat';
import type { Message } from '@/types/chat';
import ChatMessage from './ChatMessage';
import ChatInput from './ChatInput';
import ChatHeader from './ChatHeader';
import ErrorMessage from './ErrorMessage';
import { cn } from '@/lib/utils';

interface ChatMessage {
  id: string;
  role: 'user' | 'assistant';
  content: string;
  isError?: boolean;
  errorType?: string;
  errorDetails?: any;
}

export default function ChatInterface() {
  const messagesEndRef = useRef<HTMLDivElement>(null);
  const scrollAreaRef = useRef<HTMLDivElement>(null);
  const [messages, setMessages] = useState<ChatMessage[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [selectedModel, setSelectedModel] = useState<string>(DEFAULT_MODEL_ID);
  const [selectedPersonality, setSelectedPersonality] = useState<PersonalityType>('diogenes');
  const [streamingContent, setStreamingContent] = useState<string>('');
  const [lastError, setLastError] = useState<any>(null);
  const { user } = useUser();

  // Initialize session
  const session = getSession() || createNewSession();

  // Get user's first name for personalization
  const firstName = isDevelopment()
    ? 'Bob' // Hardcoded for development
    : user?.firstName || user?.username || 'wanderer';

  // Load saved preferences on mount
  useEffect(() => {
    const savedModel = localStorage.getItem('preferredModel');
    if (savedModel) {
      setSelectedModel(savedModel);
    }
    
    const savedPersonality = localStorage.getItem('preferredPersonality') as PersonalityType;
    if (savedPersonality) {
      setSelectedPersonality(savedPersonality);
    }
  }, []);

  // Add welcome message on first load
  useEffect(() => {
    const currentSession = getSession();
    if (!currentSession || currentSession.messages.length === 0) {
      const welcomeContent = selectedPersonality === 'bob' 
        ? BOB_CONVERSATION_STARTERS[Math.floor(Math.random() * BOB_CONVERSATION_STARTERS.length)]
        : getRandomStarter();
      
      const welcomeMessage: ChatMessage = {
        id: Date.now().toString(),
        role: 'assistant',
        content: welcomeContent,
      };

      setMessages([welcomeMessage]);

      // Save welcome message to session
      const newSession = createNewSession();
      addMessageToSession(newSession, {
        ...welcomeMessage,
        timestamp: new Date(),
      });
    } else {
      // Load messages from session
      const sessionMessages: ChatMessage[] = currentSession.messages.map((msg) => ({
        id: msg.id,
        role: msg.role as 'user' | 'assistant',
        content: msg.content,
      }));
      setMessages(sessionMessages);
    }
  }, []);

  // Auto-scroll to bottom
  useEffect(() => {
    if (messagesEndRef.current) {
      messagesEndRef.current.scrollIntoView({ behavior: 'smooth' });
    }
  }, [messages, streamingContent]);

  const handleNewConversation = useCallback(() => {
    if (confirm('Start a new conversation? Current conversation will be cleared.')) {
      clearSession();
      window.location.reload();
    }
  }, []);

  const handleDownloadTranscript = useCallback(() => {
    // Format the conversation as markdown
    const timestamp = new Date().toISOString().split('T')[0];
    let transcript = '# Diogenes Conversation Transcript\n';
    transcript += `Date: ${new Date().toLocaleDateString()}\n`;
    transcript += `Time: ${new Date().toLocaleTimeString()}\n`;
    transcript += `User: ${firstName}\n`;
    transcript += `Model: ${selectedModel}\n\n`;
    transcript += '---\n\n';

    messages.forEach((msg) => {
      const role = msg.role === 'user' ? `**${firstName}**` : '**Diogenes**';
      transcript += `${role}:\n${msg.content}\n\n`;
    });

    transcript += '---\n\n';
    transcript += '_Generated by Diogenes - The Digital Cynic_\n';

    // Create and download the file
    const blob = new Blob([transcript], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `diogenes-chat-${timestamp}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, [messages, firstName, selectedModel]);

  const handleSendMessage = useCallback(async (content: string) => {
    if (!content.trim() || isLoading) {
      return;
    }

    // Add user message to UI
    const userMessage: ChatMessage = {
      id: `user-${Date.now()}`,
      role: 'user',
      content: content.trim(),
    };

    setMessages((prev) => [...prev, userMessage]);
    setIsLoading(true);
    setStreamingContent('');

    // Save user message to session
    const userTokens = estimateTokens(content.trim());
    const sessionUserMessage: Message = {
      id: userMessage.id,
      role: 'user',
      content: content.trim(),
      timestamp: new Date(),
      tokenUsage: {
        promptTokens: userTokens,
        completionTokens: 0,
        totalTokens: userTokens,
        cost: calculateCost(userTokens, 0),
      },
    };

    const currentSession = getSession() || createNewSession();
    addMessageToSession(currentSession, sessionUserMessage);

    try {
      // Send to API
      const response = await fetch('/api/chat', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          messages: [...messages, userMessage].map((msg) => ({
            role: msg.role,
            content: msg.content,
          })),
          firstName: firstName,
          model: selectedModel,
          personality: selectedPersonality,
        }),
      });

      if (!response.ok) {
        // Try to parse error response
        let errorData;
        try {
          errorData = await response.json();
        } catch {
          errorData = { 
            error: 'API Error',
            message: `Request failed with status ${response.status}` 
          };
        }
        
        // Throw with parsed error data
        const error = new Error(errorData.message || `API error: ${response.status}`);
        (error as any).errorData = errorData;
        (error as any).status = response.status;
        throw error;
      }

      // Read the streaming response
      const reader = response.body?.getReader();
      const decoder = new TextDecoder();

      if (!reader) {
        throw new Error('No response body');
      }

      // Create assistant message
      const assistantMessage: ChatMessage = {
        id: `assistant-${Date.now()}`,
        role: 'assistant',
        content: '',
      };

      setMessages((prev) => [...prev, assistantMessage]);

      let fullContent = '';

      while (true) {
        const { done, value } = await reader.read();

        if (done) {
          break;
        }

        const chunk = decoder.decode(value, { stream: true });
        fullContent += chunk;
        setStreamingContent(fullContent);

        // Update the assistant message with accumulated content
        setMessages((prev) =>
          prev.map((msg) =>
            msg.id === assistantMessage.id ? { ...msg, content: fullContent } : msg
          )
        );
      }

      // Save assistant response to session
      const completionTokens = estimateTokens(fullContent);
      const promptTokens = estimateMessagesTokens(
        [...messages, userMessage].map((msg) => ({
          role: msg.role,
          content: msg.content,
        }))
      );

      const sessionAssistantMessage: Message = {
        id: assistantMessage.id,
        role: 'assistant',
        content: fullContent,
        timestamp: new Date(),
        tokenUsage: {
          promptTokens: promptTokens,
          completionTokens: completionTokens,
          totalTokens: promptTokens + completionTokens,
          cost: calculateCost(promptTokens, completionTokens),
        },
      };

      addMessageToSession(currentSession, sessionAssistantMessage);
    } catch (error: any) {
      console.error('Error sending message:', error);

      // Store error for display
      const errorData = error.errorData || {
        type: 'UnknownError',
        message: error.message || 'An unexpected error occurred. Please try again.',
        details: isDevelopment() ? { originalError: error.toString() } : undefined
      };

      setLastError(errorData);

      // Show error message
      const errorMessage: ChatMessage = {
        id: `error-${Date.now()}`,
        role: 'assistant',
        content: errorData.message,
        isError: true,
        errorType: errorData.type,
        errorDetails: errorData.details
      };

      setMessages((prev) => [...prev, errorMessage]);
      
      // Remove any empty loading messages
      setMessages((prev) => prev.filter(msg => !(msg.role === 'assistant' && msg.content === '')));
    } finally {
      setIsLoading(false);
      setStreamingContent('');
    }
  }, [messages, isLoading, firstName, selectedModel]);

  // Get current session for token metrics
  const currentSession = getSession() || createNewSession();

  return (
    <div className="flex flex-col h-screen bg-gradient-to-b from-background to-muted/20">
      {/* Header */}
      <ChatHeader
        session={currentSession}
        selectedModel={selectedModel}
        onModelChange={(model) => {
          setSelectedModel(model);
          localStorage.setItem('preferredModel', model);
        }}
        selectedPersonality={selectedPersonality}
        onPersonalityChange={(personality) => {
          setSelectedPersonality(personality);
          localStorage.setItem('preferredPersonality', personality);
        }}
        onNewConversation={handleNewConversation}
        onDownloadTranscript={handleDownloadTranscript}
        userName={firstName}
        messagesCount={messages.length}
      />

      {/* Messages Area */}
      <ScrollArea 
        ref={scrollAreaRef}
        className="flex-1 px-4"
      >
        <div className="max-w-4xl mx-auto py-6 space-y-4">
          {messages.length === 0 && (
            <Card className="p-8 text-center">
              <h2 className="text-2xl font-semibold mb-2">Welcome, {firstName}</h2>
              <p className="text-muted-foreground">
                Challenge me with your questions. I shall respond with the brutal honesty 
                that modern society desperately needs.
              </p>
            </Card>
          )}

          {messages.map((message) => (
            message.isError ? (
              <ErrorMessage
                key={message.id}
                type={message.errorType}
                message={message.content}
                details={message.errorDetails}
                isDevelopment={isDevelopment()}
                onRetry={() => {
                  // Remove the error message and retry
                  setMessages((prev) => prev.filter(m => m.id !== message.id));
                  setLastError(null);
                }}
              />
            ) : (
              <ChatMessage
                key={message.id}
                message={message}
                userName={firstName}
              />
            )
          ))}

          {isLoading && streamingContent === '' && (
            <div className="flex items-center gap-3 text-muted-foreground">
              <div className="h-8 w-8 rounded-full bg-gradient-to-br from-amber-600 to-amber-700 flex items-center justify-center">
                <Loader2 className="h-4 w-4 text-white animate-spin" />
              </div>
              <div className="flex gap-1">
                <span className="animate-pulse">Contemplating</span>
                <span className="animate-pulse animation-delay-100">.</span>
                <span className="animate-pulse animation-delay-200">.</span>
                <span className="animate-pulse animation-delay-300">.</span>
              </div>
            </div>
          )}

          <div ref={messagesEndRef} />
        </div>
      </ScrollArea>

      {/* Input Area */}
      <div className="border-t bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
        <div className="max-w-4xl mx-auto">
          <ChatInput
            onSubmit={handleSendMessage}
            isLoading={isLoading}
            placeholder="Challenge Diogenes with your question..."
          />
        </div>
      </div>
    </div>
  );
}